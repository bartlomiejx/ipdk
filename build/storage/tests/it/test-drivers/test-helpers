#!/usr/bin/env bash
#
# Copyright (C) 2022 Intel Corporation
# SPDX-License-Identifier: Apache-2.0
#

[ "$DEBUG_VM" == 'true' ] && export GRPC_VERBOSITY=DEBUG

current_script_dir=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &> /dev/null && pwd)
root_dir=${current_script_dir}/../../..
scripts_dir=${root_dir}/scripts

# shellcheck disable=SC1091,SC1090
source "${scripts_dir}"/socket.sh
# shellcheck disable=SC1091,SC1090
source "${scripts_dir}"/disk_infrastructure.sh
# shellcheck disable=SC1091,SC1090
source "${scripts_dir}"/vm/vm_default_variables.sh

function wait_until_vm_is_up() {
	local vm_addr="$1"
	local ssh_port="$2"

	[ "$DEBUG_VM" == 'true' ] && echo "Start waiting for VM... and console ${console}"

	wait_counter=0
	max_wait_counter=20
	wait_period_sec=1
	while [ "${wait_counter}" -le "${max_wait_counter}" ] ; do
		if echo > "/dev/tcp/$vm_addr/$ssh_port" ; then
			echo "ssh is available on $vm_addr:$ssh_port"
			return 0
		fi
		sleep "${wait_period_sec}"
		wait_counter=$(( wait_counter + 1 ))
	done
	return 1
}

function wait_until_host_target_is_up() {
	local vm_addr="$1"
	local ssh_port="$2"
	local wait_counter=0
	local wait_period_sec=1
	local max_wait_counter=60
	local cmd='docker container ls | grep -c "host-target"'

	while [ "${wait_counter}" -le "${max_wait_counter}" ] ; do
		if ssh -o StrictHostKeyChecking=no \
			-o UserKnownHostsFile=/dev/null \
			-o User=root \
			-p "$ssh_port" $vm_addr \
			"$cmd" ; then
			echo "host-target container is up"
			return 0
		fi
		sleep "${wait_period_sec}"
		wait_counter=$(( wait_counter + 1 ))
	done
	echo -e $(ssh -o StrictHostKeyChecking=no \
			-o UserKnownHostsFile=/dev/null \
			-o User=root \
			-p "$ssh_port" $vm_addr \
			"docker ps ; systemctl status docker | cat ; systemctl status host-target | cat")
	return 1
}

function send_fio_cmd() {
	local traffic_generator_ip="$1"
	local host_target_service_port="$2"
	local device_handle="$3"
	local fio_args="$4"
	local volume_id="$5"
	local out=""
	local volume_argument=""

	if [ -n "$volume_id" ] ; then
		volume_argument="volumeId: '$volume_id'"
	fi
	out=$(env -i no_grpc_proxy="" grpc_cli call \
		"$traffic_generator_ip:$host_target_service_port" \
		RunFio "diskToExercise: { deviceHandle: '$device_handle' $volume_argument} \
		fioArgs: '$fio_args'")
	result="$?"
	echo "$out"
	return "$result"
}

function log_in_with_default_credentials() {
	local vm_ip_addr="$1"
	local ssh_port="${2-$SSH_PORT}"
	local key="~/.ssh/id_rsa"
	if [ ! -f  "$key" ] ; then
		ssh-keygen -t rsa -C "no@email.com" -f ~/.ssh/id_rsa -P "" <<<y >/dev/null 2>&1
	fi
	sshpass -p "root" ssh-copy-id -f \
		-i ~/.ssh/id_rsa.pub \
		-p "$ssh_port" \
		-o StrictHostKeyChecking=no \
		root@"$vm_ip_addr"
}

function hostname_to_ip() {
	getent hosts "${1}" | awk '{ print $1 }'
}

function _is_max_limit_qos_supported() {
    local qos_capabilities="$1"
    local limit_type="$2"
    local limit_level_type="$3"
    local limit_type_support=""
    local limit_type_support=""
	limit_type_support=$(echo "$qos_capabilities" | jq -r ".$limit_level_type.$limit_type")
    if [[ -n "$limit_type_support" && "$limit_type_support" == "true" ]]; then
        return 0
    fi
    return 1
}

function _is_max_volume_limit_qos_supported() {
	_is_max_limit_qos_supported "$@" "max_volume_caps"
    return $?
}

function is_max_volume_read_write_bandwidth_qos_supported() {
    _is_max_volume_limit_qos_supported "$@" "rw_bandwidth"
    return $?
}

function is_max_volume_read_bandwidth_qos_supported() {
    _is_max_volume_limit_qos_supported "$@" "rd_bandwidth"
    return $?
}

function is_max_volume_write_bandwidth_qos_supported() {
    _is_max_volume_limit_qos_supported "$@" "wr_bandwidth"
    return $?
}

function is_max_volume_read_write_iops_qos_supported() {
    _is_max_volume_limit_qos_supported "$@" "rw_iops"
    return $?
}

function is_max_volume_read_iops_qos_supported() {
    _is_max_volume_limit_qos_supported "$@" "rd_iops"
    return $?
}

function is_max_volume_write_iops_qos_supported() {
    _is_max_volume_limit_qos_supported "$@" "wr_iops"
    return $?
}

function _is_max_device_limit_qos_supported() {
	_is_max_limit_qos_supported "$@" "max_device_caps"
    return $?
}

function is_max_device_read_write_bandwidth_qos_supported() {
    _is_max_device_limit_qos_supported "$@" "rw_bandwidth"
    return $?
}

function is_max_device_read_bandwidth_qos_supported() {
    _is_max_device_limit_qos_supported "$@" "rd_bandwidth"
    return $?
}

function is_max_device_write_bandwidth_qos_supported() {
    _is_max_device_limit_qos_supported "$@" "wr_bandwidth"
    return $?
}

function is_max_device_read_write_iops_qos_supported() {
    _is_max_device_limit_qos_supported "$@" "rw_iops"
    return $?
}

function is_max_device_read_iops_qos_supported() {
    _is_max_device_limit_qos_supported "$@" "rd_iops"
    return $?
}

function is_max_device_write_iops_qos_supported() {
    _is_max_device_limit_qos_supported "$@" "wr_iops"
    return $?
}

function is_device_qos_supported() {
    local qos_capabilities="$1"
	echo "$qos_capabilities" | jq -e .max_device_caps
	return $?
}

function is_volume_qos_supported() {
    local qos_capabilities="$1"
	echo "$qos_capabilities" | jq -e .max_volume_caps
	return $?
}

function get_mean_read_bandwidth_from_fio_output() {
	local fio_output="$1"
	echo "${fio_output}" | jq -r '.fioOutput' | jq -r '.jobs[].read.bw'
}

function get_mean_write_bandwidth_from_fio_output() {
	local fio_output="$1"
	echo "${fio_output}" | jq -r '.fioOutput' | jq -r '.jobs[].write.bw'
}

function get_mean_read_iops_from_fio_output() {
	local fio_output="$1"
	printf "%.0f" "$(echo "${fio_output}" | jq -r '.fioOutput' | jq -r '.jobs[].read.iops')"
}

function get_mean_write_iops_from_fio_output() {
	local fio_output="$1"
	printf "%.0f" "$(echo "${fio_output}" | jq -r '.fioOutput' | jq -r '.jobs[].write.iops')"
}

function transform_fio_output_to_parsebale_form() {
	local fio_out="$1"
	fio_out="{ $fio_out }"
	fio_out=$(echo "$fio_out" | sed -r 's/\"/"/g' | sed -r 's/fioOutput/"fioOutput"/g')
	echo "$fio_out"
}

function get_number_of_virtio_blk() {
    python3 <<- EOF
from scripts import disk_infrastructure

print(disk_infrastructure.get_number_of_virtio_blk(addr="${1}", ssh_port=int("${2}")))
EOF
}

function get_number_of_nvme_devices() {
    python3 <<- EOF
from scripts import disk_infrastructure

print(disk_infrastructure.get_number_of_nvme_devices(addr="${1}", ssh_port=int("${2}")))
EOF
}

function is_virtio_blk_attached() {
    python3 <<- EOF
import sys
from scripts import disk_infrastructure

if not disk_infrastructure.is_virtio_blk_attached(addr="${1}", ssh_port=int("${2}")):
    sys.exit(1)
EOF
}

function is_virtio_blk_not_attached() {
    python3 <<- EOF
import sys
from scripts import disk_infrastructure

if disk_infrastructure.is_virtio_blk_attached(addr="${1}", ssh_port=int("${2}")):
    sys.exit(1)
EOF
}

function verify_expected_number_of_virtio_blk_devices() {
    python3 <<- EOF
import sys
from scripts import disk_infrastructure

if not disk_infrastructure.verify_expected_number_of_virtio_blk_devices(
    addr="${1}",
    ssh_port=int("${2}"),
    expected_number_of_devices=int("${3}"),
):
    sys.exit(1)
EOF
}

function verify_expected_number_of_nvme_devices() {
    python3 <<- EOF
import sys
from scripts import disk_infrastructure

if not disk_infrastructure.verify_expected_number_of_nvme_devices(
    addr="${1}",
    ssh_port="$2",
    expected_number_of_devices=int("${3}"),
):
    sys.exit(1)
EOF
}

function verify_expected_number_of_nvme_namespaces() {
    python3 <<- EOF
import sys
from scripts import disk_infrastructure

if not disk_infrastructure.verify_expected_number_of_nvme_namespaces(
    addr="${1}",
    ssh_port="$2",
    expected_number_of_namespaces=int("${3}"),
):
    sys.exit(1)
EOF
}

storage_target_ip=${STORAGE_TARGET_IP:-"$(hostname_to_ip storage-target)"}
export storage_target_ip="${storage_target_ip}"
ipu_storage_container_ip=${IPU_STORAGE_CONTAINER_IP:-"$(hostname_to_ip ipu-storage-container)"}
export ipu_storage_container_ip="${ipu_storage_container_ip}"
traffic_generator_ip=${TRAFFIC_GENERATOR_IP:-"$(hostname_to_ip traffic-generator)"}
export traffic_generator_ip="${traffic_generator_ip}"
export host_target_ip="$traffic_generator_ip"
export nqn="nqn.2016-06.io.spdk:cnode1"
export shared_volume=/ipdk-shared
export vm_serial=${shared_volume}/vm_socket
export port_to_expose="$DEFAULT_NVME_PORT"
export virtio_blk_virtual_id=0
export vm_ssh_port="$DEFAULT_VM_SSH_PORT"
